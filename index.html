<!DOCTYPE html>
<html lang="en">
<!--Vibe coded by KBS and Copilot-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QuantStudio qPCR results Excel spreadsheet processor</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.21.3/full/pyodide.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
        }
        th {
            background-color: #f2f2f2;
        }
        .message {
            font-family: Courier New, monospace;
            font-size: 80%;
            color: darkgreen;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>QuantStudio qPCR results Excel spreadsheet processor</h1>

    <p><a href="https://github.com/kbseah/labelmyqpcr">GitHub repo</a></p>

    <p>This tool allows you to upload an Excel file containing results from
    QuantStudio 5, group the Ct values by specified sample and primer labels,
    and compute the mean and standard deviation for each group of technical
    replicates. This is useful if you did not specify the sample and target
    names in QuantStudio before starting the run, or if you wish to regroup
    them afterwards. Swarm plots of the Ct values grouped by primer, sample, or
    group labels can also be generated.</p>

    <h2>Results File Format</h2>

    <p>The exported results from QuantStudio should be in Excel format (.xls or
    .xlsx) and must contain a sheet named "Results" with columns "Well
    Position" and "CT". The Ct mean and SD values in the input spreadsheet will
    be ignored. Files produced by other instrument models can be used too if
    they follow this format.</p>

    <p>For testing you may download an <a href="example-results.xls">example
      results file</a> with well positions that correspond to the example
    values in the plate labels template sheet.</p>
    
    <p>We assume that a typical qPCR run includes technical replicates for each
    sample-primer pair, and that we wish to calculate the mean Ct value of each
    set of technical replicates. Samples may be further grouped into sample
    groups, which represent different experimental conditions that you wish to
    compare.</p>

    <h2>Prepare Labels</h2>
    <p><a href="plate-labels.xlsx">Download the plate labels spreadsheet</a>,
    which is pre-filled with some example values. There are three sheets in the
    file: "Primers", "Samples", and "SampleGroups". The sheet layout mimics the
    layout of the 384-well plate.</p>

    <p>Fill in the primer, sample, and sample group names in the respective
    sheets, leaving blank cells for any unused wells. When you upload this
    file, the tool will read the labels and use the sample-primer pairs to
    aggregate the Ct values to take the mean Ct value of each sample-primer
    pair. Any well whose Well Position (e.g. A1, B2) is not found in the
    QuantStudio Results sheet will be ignored.</p>

    <p>If you do not wish to use the sample groups, uncheck the box below. If
    sample groups and samples do not overlap consistently, the grouping for Ct
    mean calculations will be incorrect.</p>

    <h2>Upload Files to Process</h2>

    <p>Excel file with the sample and primer labels:
    <input type="file" id="labelsInput" accept=".xls, .xlsx"></p>
    <!--Checkbox to indicate if SampleGroups sheet is present-->
    <input type="checkbox" id="useSampleGroups" checked>
    <label for="useSampleGroups">Use groups from SampleGroups sheet</label>

    <p>Excel File with qPCR Results:
    <input type="file" id="fileInput" accept=".xls, .xlsx"></p>

    <button id="processButton" onclick="processFiles()">Process Files</button>
    <div id="loadingMessage" class="message" style="display:none;">ðŸ¤– Loading libraries...</div>
    <div id="processingMessage" class="message" style="display:none;">ðŸ¤– Processing files...</div>

    <h2>Results</h2>

    <h3>Table</h3>
    <button id="downloadButton" disabled=true>Download processed table in Excel format</button>
    <div id="tableContainer" style="width:800px;"></div>

    <h3>Plot</h3>
    <p>Plot parameters can be adjusted and the plot regenerated as needed.</p>
    <p>
      Facet by:
      <select id="facetBySelect">
          <option value="none">None</option>
          <option value="primer">Primer</option>
          <option value="sample">Sample</option>
          <option value="samplegroup">SampleGroup</option>
      </select>
    </p>
    <p>
      X-axis:
      <select id="xAxisSelect">
          <option value="samplegroup">SampleGroup</option>
          <option value="sample">Sample</option>
          <option value="primer">Primer</option>
      </select>
    </p>
    <!--Input plot width and height later if needed-->
    <p>
      Panel height (inches): <input type="number" id="plotHeightInput" value="2" size="5">
    </p>
    <p>
      Panel aspect ratio (width/height):
      <input type="number" id="plotAspectInput" value="2" size="5">
    </p>
    <p>
      Number of columns to wrap when facetting:
      <input type="number" id="colWrapInput" value="3" size="5">
    </p>
    <button id="plotButton" disabled=true>Generate plot</button>
    <div id="plottingMessage" class="message" style="display:none;">ðŸ¤– Generating plot...</div>
    <div id="plotContainer"></div>

    <script>
        async function loadPyodideAndPackages() {
            // Display loading message
            document.getElementById("loadingMessage").style.display = "block";
            const pyodide = await loadPyodide();
            await pyodide.loadPackage("pandas");
            await pyodide.loadPackage("xlrd");
            await pyodide.loadPackage("micropip");
            // Install openpyxl via micropip
            await pyodide.runPythonAsync(`
import micropip
await micropip.install("openpyxl")
await micropip.install("seaborn")
import openpyxl
            `);
            return pyodide;
        }

        function arrayBufferToBase64(buffer) {
            let binary = "";
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        async function processFiles() {
            const pyodide = await loadPyodideAndPackages();
            // Display loading message
            document.getElementById("processingMessage").style.display = "block";
            document.getElementById("processButton").disabled = true;
            const labelsFile = document.getElementById("labelsInput").files[0];
            const resultsFile = document.getElementById("fileInput").files[0];
            const useSampleGroups = document.getElementById("useSampleGroups").checked;
            if (!labelsFile || !resultsFile) {
                alert("Please upload both the labels file and the results file.");
                document.getElementById("loadingMessage").style.display = "none";
                document.getElementById("processingMessage").style.display = "none";
                document.getElementById("processButton").disabled = false;
                return; 
            }
            // Read labels file
            const labelsReader = new FileReader();
            labelsReader.onload = async (e) => {
                const labelsArrayBuffer = e.target.result;
                const labelsBase64Data = arrayBufferToBase64(labelsArrayBuffer);
                const pythonCodeForLabels = `
import pandas as pd
import io
import base64
file_data = base64.b64decode("${labelsBase64Data}")
excel_data = io.BytesIO(file_data)
primer_labels = pd.read_excel(excel_data, sheet_name="Primers", index_col=0)
sample_labels = pd.read_excel(excel_data, sheet_name="Samples", index_col=0)
samplegroup_labels = pd.read_excel(excel_data, sheet_name="SampleGroups", index_col=0)
primer_labels = primer_labels.melt(ignore_index=False, var_name="col", value_name="primer").reset_index()
primer_labels["Well Position"] = primer_labels["PLATE"] + primer_labels["col"].astype(str)
primer_labels.drop(["PLATE","col"],axis=1,inplace=True)
sample_labels = sample_labels.melt(ignore_index=False, var_name="col", value_name="sample").reset_index()
sample_labels["Well Position"] = sample_labels["PLATE"] + sample_labels["col"].astype(str)
sample_labels.drop(["PLATE","col"],axis=1,inplace=True)
if "${useSampleGroups}" == "true":
  samplegroup_labels = samplegroup_labels.melt(ignore_index=False, var_name="col", value_name="samplegroup").reset_index()
  samplegroup_labels["Well Position"] = samplegroup_labels["PLATE"] + samplegroup_labels["col"].astype(str)
  samplegroup_labels.drop(["PLATE","col"],axis=1,inplace=True)
else:
  samplegroup_labels = sample_labels[["Well Position"]].copy()
  samplegroup_labels["samplegroup"] = "ungrouped"
(primer_labels, sample_labels, samplegroup_labels)`;
                const [primer_labels, sample_labels, samplegroup_labels] = await pyodide.runPythonAsync(pythonCodeForLabels);
                // Read results file
                const resultsReader = new FileReader();
                resultsReader.onload = async (e) => {
                    const resultsArrayBuffer = e.target.result;
                    const resultsBase64Data = arrayBufferToBase64(resultsArrayBuffer);
                    const pythonCodeForResults = `
file_data = base64.b64decode("${resultsBase64Data}")
excel_data = io.BytesIO(file_data)
# Find out how many lines of metadata to skip
_df = pd.read_excel(excel_data, sheet_name="Results")
header_row = (_df.iloc[:,0] == "Well").idxmax()
# Import again starting from the actual header row
df = pd.read_excel(excel_data, sheet_name="Results", skiprows=header_row+1)[["Well Position", "CT"]]
df["CT"] = pd.to_numeric(df["CT"], errors="coerce") # invalid parsing will be set as NaN
df = df.merge(
  sample_labels, on="Well Position", how="left"
).merge(
  primer_labels, on="Well Position", how="left"
).merge(
  samplegroup_labels, on="Well Position", how="left"
)
df_grouped = df.groupby(["primer", "sample", "samplegroup"])["CT"].agg(["mean","std","count"]).reset_index()
html_table = df_grouped.to_html(index=False)
(df_grouped, html_table)`;
                    const [df_grouped, html_table] = await pyodide.runPythonAsync(pythonCodeForResults);
                    document.getElementById("tableContainer").innerHTML = html_table;
                    document.getElementById("loadingMessage").style.display = "none";
                    document.getElementById("processingMessage").style.display = "none";
                    document.getElementById("processButton").disabled = false;
                };
                resultsReader.readAsArrayBuffer(resultsFile);
                // Activate download button and let user download df_grouped as an Excel file to a file name of their choice
                document.getElementById("downloadButton").disabled = false;
                document.getElementById("downloadButton").onclick = async () => {
                    const pythonCodeForDownload = `
output = io.BytesIO()
with pd.ExcelWriter(output, engine="openpyxl") as writer:
    df_grouped.to_excel(writer, index=False, sheet_name="CT Summary")
output.seek(0)
excel_data = output.read()
base64.b64encode(excel_data).decode("utf-8")`;
                    const excelBase64 = await pyodide.runPythonAsync(pythonCodeForDownload);
                    const excelBlob = new Blob([Uint8Array.from(atob(excelBase64), c => c.charCodeAt(0))], {type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"});
                    const downloadLink = document.createElement("a");
                    downloadLink.href = URL.createObjectURL(excelBlob);
                    downloadLink.download = "ct_summary.xlsx";
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                };
                // Plot df_grouped as swarmplot using seaborn and plot options from the dropdowns
                document.getElementById("plotButton").disabled = false;
                document.getElementById("plotButton").onclick = async () => {
                  document.getElementById("plottingMessage").style.display = "block";
                  const facetBy = document.getElementById("facetBySelect").value;
                  const xAxis = document.getElementById("xAxisSelect").value;
                  const plotHeightInput = document.getElementById("plotHeightInput").value;
                  const plotAspectInput = document.getElementById("plotAspectInput").value;
                  const colWrapInput = document.getElementById("colWrapInput").value;
                  const pythonCodeForPlot = `
import seaborn as sns
col = 1 if "${facetBy}" == "none" else "${facetBy}"
fg = sns.catplot(
  data=df_grouped, col=col, col_wrap=int("${colWrapInput}"),
  x="${xAxis}", y="mean", kind="swarm",
  height=int("${plotHeightInput}"), aspect=int("${plotAspectInput}"),
)
buf = io.BytesIO()
fg.savefig(buf, format="png")
buf.seek(0)
img_base64 = base64.b64encode(buf.read()).decode("utf-8")
img_base64`;
                  const imgBase64 = await pyodide.runPythonAsync(pythonCodeForPlot);
                  const imgElement = document.createElement("img");
                  imgElement.src = "data:image/png;base64," + imgBase64;
                  document.getElementById("plotContainer").innerHTML = "";
                  document.getElementById("plotContainer").appendChild(imgElement);
                  document.getElementById("plottingMessage").style.display = "none";
                };
            };
            labelsReader.readAsArrayBuffer(labelsFile);
        }

    </script>
</body>
