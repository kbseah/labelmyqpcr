<!DOCTYPE html>
<html lang="en">
<!--Vibe coded by KBS and Copilot-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QuantStudio Excel sheet CT value summarizer</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.21.3/full/pyodide.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
        }
        th {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>
    <h1>QuantStudio Excel sheet CT value summarizer</h1>

    <p><a href="https://github.com/kbseah/labelmyqpcr">GitHub repo</a></p>

    <p>This tool allows you to upload an Excel file containing results from
    QuantStudio 5, group the CT values by specified sample and primer labels,
    and compute the mean and standard deviation for each group of technical
    replicates. This is useful if you did not specify the sample and target
    names in QuantStudio before starting the run.</p>

    <p>The exported results from QuantStudio should be in Excel format (.xls or
    .xlsx) and must contain a sheet named "Results" with columns "Well
    Position" and "CT". The CT mean and SD values in the input spreadsheet will
    be ignored.</p>

    <p>For testing you may download an <a href="example-results.xls">example
      results file</a> with well positions that correspond to the example
    values in the plate labels template sheet.</p>

    <h2>Prepare Sample and Primer Labels</h2>
    <p><a href="plate-labels.xlsx">Download the plate labels spreadsheet</a>,
    which is pre-filled with some example values. There are two sheets in the
    file: "Samples" and "Primers". The sheet layout mimics the layout of the
    384-well plate.</p>

    <p>Fill in the sample and primer names in the respective sheets, leaving
    blank cells for any unused wells. When you upload this file, the tool will
    read the labels and use them to group the CT values accordingly. Any wells
    whose Well Position (e.g. A1, B2) is not found in the QuantStudio Results
    sheet will be ignored.</p>

    <h2>Upload Files to Process</h2>

    <p>Excel file with the sample and primer labels:
    <input type="file" id="labelsInput" accept=".xls, .xlsx"></p>

    <p>Excel File with qPCR Results:
    <input type="file" id="fileInput" accept=".xls, .xlsx"></p>

    <button id="processButton" onclick="processFiles()">Process Files</button>
    <div id="loadingMessage" style="display:none;">Loading libraries...</div>
    <div id="processingMessage" style="display:none;">Processing files...</div>

    <h2>Results</h2>

    <h3>Table</h3>
    <button id="downloadButton" disabled=true>Download CT Summary as Excel</button>
    <div id="tableContainer" style="width:800px;"></div>

    <h3>Plot</h3>
    <p>
      Facet by:
      <select id="facetBySelect">
          <option value="none">None</option>
          <option value="primer">Primer</option>
          <option value="sample">Sample</option>
      </select>
    </p>
    <p>
      X-axis:
      <select id="xAxisSelect">
          <option value="sample">Sample</option>
          <option value="primer">Primer</option>
      </select>
    </p>
    <!--Input plot width and height later if needed-->
    <p>
      Plot height (inches): <input type="number" id="plotHeightInput" value="2" size="5">
    </p>
    <p>
      Plot aspect ratio (width/height):
      <input type="number" id="plotAspectInput" value="2" size="5">
    </p>
    <p>
      Number of columns to wrap when facetting:
      <input type="number" id="colWrapInput" value="3" size="5">
    </p>
    <button id="plotButton" disabled=true>Generate plot</button>
    <div id="plottingMessage" style="display:none;">Generating plot...</div>
    <div id="plotContainer"></div>

    <script>
        async function loadPyodideAndPackages() {
            // Display loading message
            document.getElementById("loadingMessage").style.display = "block";
            const pyodide = await loadPyodide();
            await pyodide.loadPackage("pandas");
            await pyodide.loadPackage("xlrd");
            await pyodide.loadPackage("micropip");
            // Install openpyxl via micropip
            await pyodide.runPythonAsync(`
import micropip
await micropip.install("openpyxl")
await micropip.install("seaborn")
import openpyxl
            `);
            return pyodide;
        }

        function arrayBufferToBase64(buffer) {
            let binary = "";
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        async function processFiles() {
            const pyodide = await loadPyodideAndPackages();
            // Display loading message
            document.getElementById("processingMessage").style.display = "block";
            document.getElementById("processButton").disabled = true;
            const labelsFile = document.getElementById("labelsInput").files[0];
            const resultsFile = document.getElementById("fileInput").files[0];
            if (!labelsFile || !resultsFile) {
                alert("Please upload both the labels file and the results file.");
                document.getElementById("loadingMessage").style.display = "none";
                document.getElementById("processingMessage").style.display = "none";
                document.getElementById("processButton").disabled = false;
                return; 
            }
            // Read labels file
            const labelsReader = new FileReader();
            labelsReader.onload = async (e) => {
                const labelsArrayBuffer = e.target.result;
                const labelsBase64Data = arrayBufferToBase64(labelsArrayBuffer);
                const pythonCodeForLabels = `
import pandas as pd
import io
import base64
file_data = base64.b64decode("${labelsBase64Data}")
excel_data = io.BytesIO(file_data)
primer_labels = pd.read_excel(excel_data, sheet_name="Primers", index_col=0)
sample_labels = pd.read_excel(excel_data, sheet_name="Samples", index_col=0)
primer_labels = primer_labels.melt(ignore_index=False, var_name="col", value_name="primer").reset_index()
primer_labels["Well Position"] = primer_labels["PLATE"] + primer_labels["col"].astype(str)
primer_labels.drop(["PLATE","col"],axis=1,inplace=True)
sample_labels = sample_labels.melt(ignore_index=False, var_name="col", value_name="sample").reset_index()
sample_labels["Well Position"] = sample_labels["PLATE"] + sample_labels["col"].astype(str)
sample_labels.drop(["PLATE","col"],axis=1,inplace=True)
(primer_labels, sample_labels)`;
                const [primer_labels, sample_labels] = await pyodide.runPythonAsync(pythonCodeForLabels);
                // Read results file
                const resultsReader = new FileReader();
                resultsReader.onload = async (e) => {
                    const resultsArrayBuffer = e.target.result;
                    const resultsBase64Data = arrayBufferToBase64(resultsArrayBuffer);
                    const pythonCodeForResults = `
file_data = base64.b64decode("${resultsBase64Data}")
excel_data = io.BytesIO(file_data)
# Find out how many lines of metadata to skip
_df = pd.read_excel(excel_data, sheet_name="Results")
header_row = (_df.iloc[:,0] == "Well").idxmax()
# Import again starting from the actual header row
df = pd.read_excel(excel_data, sheet_name="Results", skiprows=header_row+1)[["Well Position", "CT"]]
df["CT"] = pd.to_numeric(df["CT"], errors="coerce") # invalid parsing will be set as NaN
df = df.merge(sample_labels, on="Well Position", how="left").merge(primer_labels, on="Well Position", how="left")
df_grouped = df.groupby(["primer", "sample"])["CT"].agg(["mean","std","count"]).reset_index()
html_table = df_grouped.to_html(index=False)
(df_grouped, html_table)`;
                    const [df_grouped, html_table] = await pyodide.runPythonAsync(pythonCodeForResults);
                    document.getElementById("tableContainer").innerHTML = html_table;
                    document.getElementById("loadingMessage").style.display = "none";
                    document.getElementById("processingMessage").style.display = "none";
                    document.getElementById("processButton").disabled = false;
                };
                resultsReader.readAsArrayBuffer(resultsFile);
                // Activate download button and let user download df_grouped as an Excel file to a file name of their choice
                document.getElementById("downloadButton").disabled = false;
                document.getElementById("downloadButton").onclick = async () => {
                    const pythonCodeForDownload = `
output = io.BytesIO()
with pd.ExcelWriter(output, engine="openpyxl") as writer:
    df_grouped.to_excel(writer, index=False, sheet_name="CT Summary")
output.seek(0)
excel_data = output.read()
base64.b64encode(excel_data).decode("utf-8")`;
                    const excelBase64 = await pyodide.runPythonAsync(pythonCodeForDownload);
                    const excelBlob = new Blob([Uint8Array.from(atob(excelBase64), c => c.charCodeAt(0))], {type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"});
                    const downloadLink = document.createElement("a");
                    downloadLink.href = URL.createObjectURL(excelBlob);
                    downloadLink.download = "ct_summary.xlsx";
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                };
                // Plot df_grouped as swarmplot using seaborn and plot options from the dropdowns
                document.getElementById("plotButton").disabled = false;
                document.getElementById("plotButton").onclick = async () => {
                  document.getElementById("plottingMessage").style.display = "block";
                  const facetBy = document.getElementById("facetBySelect").value;
                  const xAxis = document.getElementById("xAxisSelect").value;
                  const plotHeightInput = document.getElementById("plotHeightInput").value;
                  const plotAspectInput = document.getElementById("plotAspectInput").value;
                  const colWrapInput = document.getElementById("colWrapInput").value;
                  const pythonCodeForPlot = `
import seaborn as sns
col = 1 if "${facetBy}" == "none" else "${facetBy}"
fg = sns.catplot(
  data=df_grouped, col=col, col_wrap=int("${colWrapInput}"),
  x="${xAxis}", y="mean", kind="swarm",
  height=int("${plotHeightInput}"), aspect=int("${plotAspectInput}"),
)
buf = io.BytesIO()
fg.savefig(buf, format="png")
buf.seek(0)
img_base64 = base64.b64encode(buf.read()).decode("utf-8")
img_base64`;
                  const imgBase64 = await pyodide.runPythonAsync(pythonCodeForPlot);
                  const imgElement = document.createElement("img");
                  imgElement.src = "data:image/png;base64," + imgBase64;
                  document.getElementById("plotContainer").innerHTML = "";
                  document.getElementById("plotContainer").appendChild(imgElement);
                  document.getElementById("plottingMessage").style.display = "none";
                };
            };
            labelsReader.readAsArrayBuffer(labelsFile);
        }

    </script>
</body>
