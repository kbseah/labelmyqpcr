<!DOCTYPE html>
<html lang="en">
<!--Vibe coded by KBS and Copilot-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QuantStudio Excel sheet CT value summarizer</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.21.3/full/pyodide.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
        }
        th {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>
    <h1>QuantStudio Excel sheet CT value summarizer</h1>
    <p>This tool allows you to upload an Excel file containing results from
    QuantStudio 5, group the CT values by specified sample and primer labels,
    and compute the mean and standard deviation for each group. This is useful
    if you did not specify the sample and target names in QuantStudio before
    starting the run. The exported results from QuantStudio should be in Excel
    format (.xls or .xlsx) and must contain a sheet named "Results" with
    columns "Well Position" and "CT". The CT mean and SD values in the input
    spreadsheet will be ignored.</p>

    <p>For testing you may download an <a href="example-results.xls">example
      results file</a> with well positions that correspond to the example
    values in the plate labels template sheet.</p>

    <h2>Prepare Sample and Primer Labels</h2>
    <p><a href="plate-labels.xlsx">Download the plate labels spreadsheet</a>,
    which is pre-filled with some example values. There are two sheets in the
    file: "Samples" and "Primers". The sheet layout mimics the layout of the
    384-well plate.</p>

    <p>Fill in the sample and primer names in the respective sheets, leaving
    blank cells for any unused wells. When you upload this file, the tool will
    read the labels and use them to group the CT values accordingly. Any wells
    whose Well Position (e.g. A1, B2) is not found in the QuantStudio Results
    sheet will be ignored.</p>

    <h2>Upload Files to Process</h2>

    <p>Excel file with the sample and primer labels:
    <input type="file" id="labelsInput" accept=".xls, .xlsx"></p>

    <p>Excel File with qPCR Results:
    <input type="file" id="fileInput" accept=".xls, .xlsx"></p>

    <button id="processButton" onclick="processFiles()">Process Files</button>
    <div id="loadingMessage" style="display:none;">Loading libraries...</div>
    <div id="processingMessage" style="display:none;">Processing files...</div>
    <button id="downloadButton" disabled=true>Download CT Summary as Excel</button>
    <div id="tableContainer"></div>

    <script>
        async function loadPyodideAndPackages() {
            <!--Display loading message-->
            document.getElementById('loadingMessage').style.display = 'block';
            const pyodide = await loadPyodide();
            await pyodide.loadPackage("pandas");
            await pyodide.loadPackage("xlrd");
            await pyodide.loadPackage("micropip");
            <!--Install openpyxl via micropip-->
            await pyodide.runPythonAsync(`
import micropip
await micropip.install('openpyxl')
import openpyxl
            `);
            return pyodide;
        }

        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        async function processFiles() {
            const pyodide = await loadPyodideAndPackages();
            // Display loading message
            document.getElementById('processingMessage').style.display = 'block';
            document.getElementById('processButton').disabled = true;
            const labelsFile = document.getElementById('labelsInput').files[0];
            const resultsFile = document.getElementById('fileInput').files[0];
            if (!labelsFile || !resultsFile) {
                alert("Please upload both the labels file and the results file.");
                document.getElementById('loadingMessage').style.display = 'none';
                document.getElementById('processingMessage').style.display = 'none';
                document.getElementById('processButton').disabled = false;
                return; 
            }
            // Read labels file
            const labelsReader = new FileReader();
            labelsReader.onload = async (e) => {
                const labelsArrayBuffer = e.target.result;
                const labelsBase64Data = arrayBufferToBase64(labelsArrayBuffer);
                const pythonCodeForLabels = `
import pandas as pd
import io
import base64
file_data = base64.b64decode("${labelsBase64Data}")
excel_data = io.BytesIO(file_data)
primer_labels = pd.read_excel(excel_data, sheet_name="Primers", index_col=0)
sample_labels = pd.read_excel(excel_data, sheet_name="Samples", index_col=0)
primer_labels = primer_labels.melt(ignore_index=False, var_name="col", value_name="primer").reset_index()
primer_labels["Well Position"] = primer_labels["PLATE"] + primer_labels["col"].astype(str)
primer_labels.drop(['PLATE','col'],axis=1,inplace=True)
sample_labels = sample_labels.melt(ignore_index=False, var_name="col", value_name="sample").reset_index()
sample_labels["Well Position"] = sample_labels["PLATE"] + sample_labels["col"].astype(str)
sample_labels.drop(['PLATE','col'],axis=1,inplace=True)
(primer_labels, sample_labels)
                `;
                const [primer_labels, sample_labels] = await pyodide.runPythonAsync(pythonCodeForLabels);
                // Read results file
                const resultsReader = new FileReader();
                resultsReader.onload = async (e) => {
                    const resultsArrayBuffer = e.target.result;
                    const resultsBase64Data = arrayBufferToBase64(resultsArrayBuffer);
                    const pythonCodeForResults = `
file_data = base64.b64decode("${resultsBase64Data}")
excel_data = io.BytesIO(file_data)
# Find out how many lines of metadata to skip
_df = pd.read_excel(excel_data, sheet_name="Results")
header_row = (_df.iloc[:,0] == "Well").idxmax()
# Import again starting from the actual header row
df = pd.read_excel(excel_data, sheet_name="Results", skiprows=header_row+1)
columns = ["Well", "Well Position", "Sample Name", "Target Name", "CT"]
df["CT"] = pd.to_numeric(df["CT"], errors='coerce') # invalid parsing will be set as NaN
df = df[columns]
df = df.merge(sample_labels, on="Well Position", how="left")
df = df.merge(primer_labels, on="Well Position", how="left")
df_grouped = df.groupby(['primer', 'sample'])['CT'].agg(['mean','std','count']).reset_index()
html_table = df_grouped.to_html(index=False)
(df_grouped, html_table)
                    `;
                    const [df_grouped, html_table] = await pyodide.runPythonAsync(pythonCodeForResults);
                    document.getElementById('tableContainer').innerHTML = html_table;
                    document.getElementById('loadingMessage').style.display = 'none';
                    document.getElementById('processingMessage').style.display = 'none';
                    document.getElementById('processButton').disabled = false;
                };
                resultsReader.readAsArrayBuffer(resultsFile);
                // Activate download button and let user download df_grouped as an Excel file to a file name of their choice
                document.getElementById('downloadButton').disabled = false;
                document.getElementById('downloadButton').onclick = async () => {
                    const pythonCodeForDownload = `
import io
output = io.BytesIO()
with pd.ExcelWriter(output, engine='openpyxl') as writer:
    df_grouped.to_excel(writer, index=False, sheet_name='CT Summary')
output.seek(0)
excel_data = output.read()
import base64
base64.b64encode(excel_data).decode('utf-8')
                    `;
                    const excelBase64 = await pyodide.runPythonAsync(pythonCodeForDownload);
                    const excelBlob = new Blob([Uint8Array.from(atob(excelBase64), c => c.charCodeAt(0))], {type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'});
                    const downloadLink = document.createElement('a');
                    downloadLink.href = URL.createObjectURL(excelBlob);
                    downloadLink.download = 'ct_summary.xlsx';
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                };
            };
            labelsReader.readAsArrayBuffer(labelsFile);
        }

    </script>
</body>
