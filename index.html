<!DOCTYPE html>
<html lang="en">
<!--Vibe coded by KBS and Copilot-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QuantStudio Excel sheet CT value summarizer</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.21.3/full/pyodide.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
        }
        th {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>
    <h1>QuantStudio Excel sheet CT value summarizer</h1>
    <p>This tool allows you to upload an Excel file containing results from
    QuantStudio 5, group the CT values by specified row and column ranges, and
    compute the mean and standard deviation for each group. This is useful if
    you did not specify the sample and target names in QuantStudio before
    starting the run. The exported results from QuantStudio should be in Excel
    format (.xls or .xlsx) and must contain a sheet named "Results" with
    columns "Well Position" and "CT". The CT mean and SD values in the input
    spreadsheet will be ignored.</p>

    <h2>Specify Sample and Primer Labels</h2>
    <p><a href="plate-labels.xlsx">Download the plate labels spreadsheet</a>,
    which is pre-filled with some example values. There are two sheets in the
    file: "Samples" and "Primers". The sheet layout mimics the layout of the
    384-well plate. Fill in the sample and primer names in the respective
    sheets, leaving blank cells for any unused wells. When you upload this
    file, the tool will read the labels and use them to group the CT values
    accordingly. Any wells whose Well Position (e.g. A1, B2) is not found in
    the QuantStudio Results sheet will be ignored.</p>
    <p>Upload the Excel file with the sample and primer labels:</p>
    <input type="file" id="labelsInput" accept=".xls, .xlsx">
    <p>Status: <div id="loadingMessage1" style="display:none;">Ready</div></p>

    <h2>Upload Excel File with qPCR Results</h2>
    <input type="file" id="fileInput" accept=".xls, .xlsx">
    <div id="loadingMessage" style="display:none;">Loading...</div>
    <button id="processButton" onclick="processFiles()">Process Files</button>
    <button id="downloadButton">Download CT Summary as Excel</button>
    <div id="tableContainer"></div>

    <script>
        async function loadPyodideAndPackages() {
            <!--Display loading message-->
            document.getElementById('loadingMessage').style.display = 'block';
            const pyodide = await loadPyodide();
            await pyodide.loadPackage("pandas");
            await pyodide.loadPackage("xlrd");
            await pyodide.loadPackage("micropip");
            <!--Install openpyxl via micropip-->
            await pyodide.runPythonAsync(`
import micropip
await micropip.install('openpyxl')
import openpyxl
            `);
            return pyodide;
        }

        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        async function processFiles() {
            const pyodide = await loadPyodideAndPackages();
            // Display loading message
            document.getElementById('loadingMessage').style.display = 'block';
            document.getElementById('processButton').disabled = true;
            const labelsFile = document.getElementById('labelsInput').files[0];
            const resultsFile = document.getElementById('fileInput').files[0];
            if (!labelsFile || !resultsFile) {
                alert("Please upload both the labels file and the results file.");
                document.getElementById('loadingMessage').style.display = 'none';
                document.getElementById('processButton').disabled = false;
                return; 
            }
            // Read labels file
            const labelsReader = new FileReader();
            labelsReader.onload = async (e) => {
                const labelsArrayBuffer = e.target.result;
                const labelsBase64Data = arrayBufferToBase64(labelsArrayBuffer);
                const pythonCodeForLabels = `
import pandas as pd
import io
import base64
file_data = base64.b64decode("${labelsBase64Data}")
excel_data = io.BytesIO(file_data)
primer_labels = pd.read_excel(excel_data, sheet_name="Primers", index_col=0)
sample_labels = pd.read_excel(excel_data, sheet_name="Samples", index_col=0)
primer_labels = primer_labels.melt(ignore_index=False, var_name="col", value_name="primer").reset_index()
primer_labels["Well Position"] = primer_labels["PLATE"] + primer_labels["col"].astype(str)
primer_labels.drop(['PLATE','col'],axis=1,inplace=True)
sample_labels = sample_labels.melt(ignore_index=False, var_name="col", value_name="sample").reset_index()
sample_labels["Well Position"] = sample_labels["PLATE"] + sample_labels["col"].astype(str)
sample_labels.drop(['PLATE','col'],axis=1,inplace=True)
(primer_labels, sample_labels)
                `;
                const [primer_labels, sample_labels] = await pyodide.runPythonAsync(pythonCodeForLabels);
                // Read results file
                const resultsReader = new FileReader();
                resultsReader.onload = async (e) => {
                    const resultsArrayBuffer = e.target.result;
                    const resultsBase64Data = arrayBufferToBase64(resultsArrayBuffer);
                    const pythonCodeForResults = `
file_data = base64.b64decode("${resultsBase64Data}")
excel_data = io.BytesIO(file_data)
# Find out how many lines of metadata to skip
_df = pd.read_excel(excel_data, sheet_name="Results")
header_row = (_df.iloc[:,0] == "Well").idxmax()
# Import again starting from the actual header row
df = pd.read_excel(excel_data, sheet_name="Results", skiprows=header_row+1)
columns = ["Well", "Well Position", "Sample Name", "Target Name", "CT"]
df["CT"] = pd.to_numeric(df["CT"], errors='coerce') # invalid parsing will be set as NaN
df = df[columns]
df = df.merge(sample_labels, on="Well Position", how="left")
df = df.merge(primer_labels, on="Well Position", how="left")
df_grouped = df.groupby(['primer', 'sample'])['CT'].agg(['mean','std','count']).reset_index()
html_table = df_grouped.to_html(index=False)
(df_grouped, html_table)
                    `;
                    const [df_grouped, html_table] = await pyodide.runPythonAsync(pythonCodeForResults);
                    document.getElementById('tableContainer').innerHTML = html_table;
                    document.getElementById('loadingMessage').style.display = 'none';
                    document.getElementById('processButton').disabled = false;
                };
                resultsReader.readAsArrayBuffer(resultsFile);
            };
            labelsReader.readAsArrayBuffer(labelsFile);
        }

    </script>
</body>
